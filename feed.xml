<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>George&#39;s dream port</title>
    <description>Yet another tech blog!</description>
    <link>http://codethoughts.info/</link>
    <atom:link href="http://codethoughts.info/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 22 Mar 2015 16:54:41 +0800</pubDate>
    <lastBuildDate>Sun, 22 Mar 2015 16:54:41 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>understanding java.lang.ref package</title>
        <description>&lt;p&gt;There’re several useful classes under package &lt;code&gt;java.lang.ref.*&lt;/code&gt;, which seems to be a little-known feature. That’s what I’m going to talk about in this blog post.&lt;/p&gt;

&lt;h3 id=&quot;a-program-with-memory-leak&quot;&gt;A Program with Memory Leak&lt;/h3&gt;
&lt;p&gt;As Java developer, most of time, you should not pay attention to memory management, JVM GC do that job for you automatically. It can easily lead to the impression that you don’t have to think about memory management, but this isn’t quite true. Consider the following simple cache implementation:
&lt;!--more--&gt;
```java
import java.util.HashMap;
import java.util.Map;
/&lt;em&gt;ATTENTION, BUGS AHEAD.&lt;/em&gt;/
public class UserDataCache {
    private Map&amp;lt;String, Object&amp;gt; cache = new HashMap&amp;lt;&amp;gt;();&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public Object getData(String key) {
    if (key == null) {
        throw new NullPointerException(&quot;Key should not be null.&quot;);
    }
    return cache.get(key);
}

public void putData(String key, Object data) {
    if (key == null) {
        throw new NullPointerException(&quot;Key should not be null.&quot;);
    }
    cache.put(key, data);
} } ``` If you check above code carefully, you may find that there&#39;s a memory leak in side the &amp;lt;code&amp;gt;getData()&amp;lt;/code&amp;gt; method. If a cache grows and then shrinks, the objects that were cached will not be garbage collected, even if the program using the cache has no more references to them. This is because the cache maintains obsolete references to these objects. An obsolete reference is simply a reference that will never be dereferenced again. In this case, any references outside of the “active portion” of the element map are obsolete. The active portion consists of the elements whose index is less than size.[^1]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;solutions-to-the-memory-leak&quot;&gt;Solutions to the Memory Leak&lt;/h3&gt;
&lt;p&gt;Now comes the solutions to this memory leak issue. Here I will present several solutions to memory leak in Java program briefly. Since the point of this blog post is about Reference type, I’ll talk more on that.&lt;/p&gt;

&lt;p&gt;Solution 1: use &lt;code&gt;java.util.LinkedHashMap&lt;/code&gt; instead, code shown as below:
```java
import java.util.LinkedHashMap;
import java.util.Map;&lt;/p&gt;

&lt;p&gt;public class LinkedHashMapCache {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private final static int CACHE_MAX_SIZE = 100;
private LinkedHashMap&amp;lt;String, Object&amp;gt; cache;

public LinkedHashMapCache() {
    this.cache = new LinkedHashMap&amp;lt;String, Object&amp;gt;(CACHE_MAX_SIZE, 0.75f, true) {
        protected boolean removeEldestEntry(
                Map.Entry&amp;lt;String, Object&amp;gt; eldest) {
            // Remove the eldest entry if the size of the cache exceeds the maximum size
            return size() &amp;gt; CACHE_MAX_SIZE;
        }
    };
}

public Object getData(String key) {
    if (key == null)
        throw new NullPointerException(&quot;Key should not be null.&quot;);
    return cache.get(key);
}

public void putData(String key, Object data) {
    if (key == null)
        throw new NullPointerException(&quot;Key should not be null.&quot;);
    cache.put(key, data);
} } ``` In above code, whenever the total entries exceed the maximum size of the map, the eldest entry will be overwritten as the latest one, so the memory leak issue is eliminated. More commonly, the useful lifetime of a cache entry is less well defined, with entries becoming less valuable over time. Under these circumstances, the cache should occasionally be cleaned of entries that have fallen into disuse. This can be done by a background thread (perhaps a &amp;lt;code&amp;gt;Timer&amp;lt;/code&amp;gt; or &amp;lt;code&amp;gt;ScheduledThreadPoolExecutor&amp;lt;/code&amp;gt;) or as a side effect of adding new entries to the cache. The &amp;lt;code&amp;gt;LinkedHashMap&amp;lt;/code&amp;gt; class facilitates the latter approach with its &amp;lt;code&amp;gt;removeEldestEntry&amp;lt;/code&amp;gt; method.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Solution 2: this is the real meat of this blog post, use &lt;code&gt;java.lang.ref.WeakHashMap&lt;/code&gt; instead of &lt;code&gt;java.util.HashMap&lt;/code&gt;
```java
import java.util.Map;
import java.util.WeakHashMap;&lt;/p&gt;

&lt;p&gt;public class WeakHashMapCache {
    private Map&amp;lt;String, Object&amp;gt; map = new WeakHashMap&amp;lt;&amp;gt;();&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* This put() will return any data associated with key. */
public void put(String key, Object data) {
    if (key == null)
        throw new NullPointerException(&quot;Key cannot be null.&quot;);
    map.put(key, data);
}

/* This get() will return the data specified by key, or null if no
 data was put there, or if the object was garbage collected. */
public Object get(String key) {
    if (key == null)
        throw new NullPointerException(&quot;Key cannot be null.&quot;);
    return map.get(key);
} } ``` Why could the &amp;lt;code&amp;gt;java.lang.ref.WeakHashMap&amp;lt;/code&amp;gt; come to rescue? Let&#39;s dig deeper into what is weak references, how to use them, and when to use them.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;description-in-javadoc-package-summaryhttpdocsoraclecomjavase7docsapijavalangrefpackage-summaryhtml-of-javalangref&quot;&gt;Description in &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/ref/package-summary.html&quot;&gt;Javadoc package summary&lt;/a&gt; of java.lang.ref&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;Provides reference-object classes, which support a limited degree of interaction with the garbage collector. A program may use a reference object to maintain a reference to some other object in such a way that the latter object may still be reclaimed by the collector. A program may also arrange to be notified some time after the collector has determined that the reachability of a given object has changed.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So what is reachability, here is the explanation from that document too:
&amp;gt;Going from strongest to weakest, the different levels of reachability reflect the life cycle of an object. They are operationally defined as follows:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;An object is strongly reachable if it can be reached by some thread without traversing any reference objects. A newly-created * object is strongly reachable by the thread that created it.&lt;/li&gt;
  &lt;li&gt;An object is softly reachable if it is not strongly reachable but can be reached by traversing a soft reference.&lt;/li&gt;
  &lt;li&gt;An object is weakly reachable if it is neither strongly nor softly reachable but can be reached by traversing a weak reference. When the weak references to a weakly-reachable object are cleared, the object becomes eligible for finalization.&lt;/li&gt;
  &lt;li&gt;An object is phantom reachable if it is neither strongly, softly, nor weakly reachable, it has been finalized, and some phantom reference refers to it.&lt;/li&gt;
  &lt;li&gt;Finally, an object is unreachable, and therefore eligible for reclamation, when it is not reachable in any of the above ways.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;At this point, you must be wondering about the difference, and the need, to have three different levels of weaker referencing mechanisms. In the order of strength, the references can be arranged as:
&lt;strong&gt;Strong References &amp;gt; Soft References &amp;gt; Weak References &amp;gt; Phantom References&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;strong-references-2&quot;&gt;Strong References &lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h3&gt;
&lt;p&gt;The references that we create using the assignment operator are known as strong references, because the instance is strongly referred by the application, making it ineligible for garbage collection.
&lt;code&gt;java
Object o = new Object();
&lt;/code&gt;
Soft, Weak and Phantom references are the weaker counterparts of referencing, where the garbage collection algorithm is allowed to mark an instance to be garbage collected, even though such a reference exists. What this means is that, even though you hold a weak reference to a particular instance, the JVM can sweep it out of the memory if it needs to. This works out great for the problem we discussed before, since instances in our cache will be automatically released if the JVM thinks it needs more memory for other parts.&lt;/p&gt;

&lt;h3 id=&quot;soft-references&quot;&gt;Soft References&lt;/h3&gt;
&lt;p&gt;According to the document of &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/ref/SoftReference.html&quot;&gt;SoftReference&lt;/a&gt;, the JVM implementations are encouraged not to clear out a soft reference if the JVM has enough memory. That is, if free heap space is available, chances are that a soft reference will not be freed during a garbage collection cycle (so it survives from GC).  However, before throwing an &lt;code&gt;OutOfMemoryError&lt;/code&gt;, JVM will attempt to reclaim memory by releasing instances that are softly reachable.  This makes Soft References ideal for implementing memory sensitive caches (as in our example problem).
```java
public class SoftReferenceSample {
    public static void main(String[] args) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    // Initial Strong Ref
    Object obj = new Object();
    System.out.println(&quot;Instance : &quot; + obj);

    // Make a Soft Reference on obj
    SoftReference&amp;lt;Object&amp;gt; softReference = new SoftReference&amp;lt;&amp;gt;(obj);

    // Make obj eligible for GC !
    obj = null;
    System.gc();    // Run GC
    // should be null if GC collected
    System.out.println(&quot;Instance : &quot; + softReference.get());
} } ```
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;weak-references&quot;&gt;Weak References&lt;/h3&gt;
&lt;p&gt;Unlike Soft References, Weak References can be reclaimed by the JVM during a GC cycle, even though there’s enough free memory available. As long as GC does not occur, we can retrieve a strong reference out of a weak reference by calling the &lt;code&gt;WeakReference#get()&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;Below is an example code of WeakReference, two of other References can be found under &lt;code&gt;java.lang.ref.*&lt;/code&gt; package:
```java
import java.lang.ref.WeakReference;&lt;/p&gt;

&lt;p&gt;public class WeakReferenceSample {
    public static void main(String[] args) {
        // Initial Strong Ref
        Object obj = new Object();
        System.out.println(“Instance : “ + obj);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    // Create a Weak Ref on obj
    WeakReference&amp;lt;Object&amp;gt; weakRef = new WeakReference&amp;lt;&amp;gt;(obj);
    // Make obj eligible for GC !
    obj = null;
    // Get a strong reference again. Now its not eligible for GC
    Object strongRef = weakRef.get();
    System.out.println(&quot;Instance : &quot; + strongRef);
    // Make the instance eligible for GC again
    strongRef = null;
    // Keep your fingers crossed
    System.gc();
    // should be null if GC collected
    System.out.println(&quot;Instance : &quot; + weakRef.get());
} } ``` From the little toy program you can see how to create WeakReference instances and how to store/get data into/from it either.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;phantom-references&quot;&gt;Phantom References&lt;/h3&gt;
&lt;p&gt;Phantom references are the weakest form of referencing. Instances that are referred via a phantom reference cannot be accessed directly using a get() method (it always returns null), as in case of Soft / Weak references. Instead, we need to rely on Reference Queues to make use of Phantom References. One use case of Phantom references is to keep track of active references within an application, and to know when those instances will be garbage collected. If we use strong references, then the instance will not be eligible for GC due to the strong reference we maintain. Instead, we could rely on a phantom reference with the support of a reference queue to handle the situation.&lt;/p&gt;

&lt;h3 id=&quot;reference-queues&quot;&gt;Reference Queues&lt;/h3&gt;
&lt;p&gt;ReferenceQueue is the mechanism provided by the JVM to be notified when a referenced instance is about to be garbage collected. Reference Queues can be used with all of the reference types by passing it to the constructor. When creating a PhantomReference, it is a must to provide a Reference Queue.&lt;/p&gt;

&lt;p&gt;Let’s see an example of reference queue:
```java
import java.lang.ref.PhantomReference;
import java.lang.ref.ReferenceQueue;&lt;/p&gt;

&lt;p&gt;public class PhantomRefQueueSample {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void main(String[] args) throws InterruptedException {

    Object obj = new Object();
    ReferenceQueue&amp;lt;Object&amp;gt; queue = new ReferenceQueue&amp;lt;&amp;gt;();
    PhantomReference&amp;lt;Object&amp;gt; pRef = new PhantomReference&amp;lt;&amp;gt;(obj, queue);
    obj = null;

    new Thread(new Runnable() {
        public void run() {
            try {
                System.out.println(&quot;Awaiting for GC&quot;);
                // This will block till it is reclaimed by JVM
                PhantomReference pRef = (PhantomReference) queue.remove();
                System.out.println(&quot;Referenced reclaimed&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }).start();

    // Wait for 2nd thread to start
    Thread.sleep(2000);

    System.out.println(&quot;Invoking GC&quot;);
    System.gc();
} } ```
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;weakhashmap&quot;&gt;WeakHashMap&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;java.util.WeakHashMap&lt;/code&gt; is a special version of the HashMap, which uses weak references as the key. Therefore, when a particular key is not in use anymore, and it is eligible for garbage collection, the corresponding entry in the WeakHashMap will magically disappear from the map. And the magic relies on ReferenceQueue mechanism explained before to identify when a particular weak reference is to be garbage collected. This is useful when you want to build a cache based on weak references. In more sophisticated requirements, it is better to write your own cache implementation.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://blog.yohanliyanage.com/2010/10/ktjs-3-soft-weak-phantom-references/&quot;&gt;Know the JVM Series -3- When Weaker is Better: Understanding Soft, Weak and Phantom References&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 07 Apr 2014 15:03:55 +0800</pubDate>
        <link>http://codethoughts.info/java/2014/04/07/understanding-java-dot-lang-dot-ref-package/</link>
        <guid isPermaLink="true">http://codethoughts.info/java/2014/04/07/understanding-java-dot-lang-dot-ref-package/</guid>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>Singleton pattern in Java</title>
        <description>&lt;p&gt;The Singleton pattern is deceptively simple, even and especially for Java developers, but it presents a number of pitfalls for the unwary Java developer which make it hard to implement properly. In this article, I’ll talk about several ways to implement the Singleton pattern in Java, and leave it to you to decide which one is best suited for your circumstance depending on your requirement.
&lt;!--more--&gt;
With the Singleton design pattern you can:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Ensure that only one instance of a class is created&lt;/li&gt;
  &lt;li&gt;Provide a global point of access to the object&lt;/li&gt;
  &lt;li&gt;Allow multiple instances in the future without affecting a singleton class’s clients&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;the-classic-singleton-pattern1&quot;&gt;The classic Singleton pattern&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h3&gt;
&lt;p&gt;In Design Patterns: &lt;a href=&quot;http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612&quot;&gt;Elements of Reusable Object-Oriented Software&lt;/a&gt;, the GoF describe the Singleton pattern like this:
&amp;gt; Ensure a class has only one instance, and provide a global point of access to it.&lt;/p&gt;

&lt;p&gt;```java
public class ClassicSingleton {
    private static ClassicSingleton instance = null;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private ClassicSingleton() {
    // Exists only to defeat instantiation.
}

public static ClassicSingleton getInstance() {
    if (instance == null) {
        instance = new ClassicSingleton();
    }
    return instance;
} } ```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Above code is easy to understand, the ClassicSingleton hold a static reference to the single instance and returns that reference from the static &lt;code&gt;getInstance()&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;There are several interesting points concerning the ClassicSingleton class. 
1. ClassicSingleton employs a technique known as lazy instantiation to create the singleton; as a result, the singleton instance is not created until the &lt;code&gt;getInstance()&lt;/code&gt; method is called for the first time. This technique ensures that singleton instances are created only when needed.
2. It’s possible to have multiple singleton instances if classes loaded by different Classloaders access a singleton. That scenario is not so far-fetched; for example, some servlet containers use distinct Classloaders for each servlet, so if two servlets access a singleton, they will each have their own instance.
3. If ClassicSingleton implements the &lt;code&gt;java.io.Serializable&lt;/code&gt; interface, the class’s instances can be serialized and deserialized. However, if you serialize a singleton object and subsequently deserialize that object more than once, you will have multiple singleton instances.
4. ClassicSingleton class is not thread-safe. If two threads—we’ll call them Thread 1 and Thread 2—call &lt;code&gt;ClassicSingleton.getInstance()&lt;/code&gt; at the same time, two ClassicSingleton instances can be created if Thread 1 is preempted just after it enters the if block and control is subsequently given to Thread 2.
5. A privileged client can invoke the private constructor reflectively with the aid of the &lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt; method. If you need to defend against this attack, modify the constructor to make it throw an exception if it’s asked to create a second instance.&lt;/p&gt;

&lt;p&gt;As you can see from the preceding discussion, although the Singleton pattern is one of the simplest design patterns, implementing it in Java is anything but simple. The rest of this article addresses Java-specific considerations for the Singleton pattern.&lt;/p&gt;

&lt;h3 id=&quot;synchronization-for-multithreading-considerations&quot;&gt;Synchronization for multithreading considerations&lt;/h3&gt;
&lt;p&gt;Making Singleton thread-safe is easy-just synchronize the &lt;code&gt;getInstance()&lt;/code&gt; method:
```java
public class Singleton {
    private static Singleton instance = null;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private Singleton() {
    // Exists only to defeat instantiation.
}

public synchronized static Singleton getInstance() {
    if (instance == null) {
        instance = new Singleton();
    }
    return instance;
} } ``` However, the astute reader may realize that the getInstance() method only needs to be synchronized the first time it is called. Because synchronization is very expensive performance-wise, perhaps we can introduce a performance enhancement that only synchronizes the singleton assignment in &amp;lt;code&amp;gt;getInstance()&amp;lt;/code&amp;gt;.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;a-performance-enhancement&quot;&gt;A performance enhancement&lt;/h3&gt;
&lt;p&gt;In search of a performance enhancement, you might choose to rewrite the &lt;code&gt;getInstance()&lt;/code&gt; method like this:
&lt;code&gt;java
// CAUTION, BUGS AHEAD
public static Singleton getInstance() {
   if(singleton == null) {
      synchronized(Singleton.class) { 
         singleton = new Singleton();
      }
   }
   return singleton;
}
&lt;/code&gt;
Instead of synchronizing the entire method, the preceding code fragment only synchronizes the critical code. However, the preceding code fragment is not thread-safe. Consider the following scenario: Thread 1 enters the synchronized block, and, before it can assign the singleton member variable, the thread is preempted. Subsequently, another thread can enter the if block. The second thread will wait for the first thread to finish, but we will still wind up with two distinct singleton instances. Is there a way to fix this problem? Read on.&lt;/p&gt;

&lt;h3 id=&quot;double-checked-locking&quot;&gt;Double-checked locking&lt;/h3&gt;
&lt;p&gt;Double-checked locking is a technique that, at first glance, appears to make lazy instantiation thread-safe. That technique is illustrated in the following code fragment:
&lt;code&gt;java
// CAUTION, BUGS AHEAD
public static Singleton getInstance() {
  if(singleton == null) {
     synchronized(Singleton.class) {
       if(singleton == null) {
         singleton = new Singleton();
       }
    }
  }
  return singleton;
}
&lt;/code&gt;
What happens if two threads simultaneously access &lt;code&gt;getInstance()&lt;/code&gt;? Imagine Thread 1 enters the synchronized block and is preempted. Subsequently, a second thread enters the if block. When Thread 1 exits the synchronized block, Thread 2 makes a second check to see if the singleton instance is still null. Since Thread 1 set the singleton member variable, Thread 2’s second check will fail, and a second singleton will not be created. Or so it seems.&lt;/p&gt;

&lt;p&gt;Unfortunately, double-checked locking is not guaranteed to work because the compiler is free to assign a value to the singleton member variable before the singleton’s constructor is called. If that happens, Thread 1 can be preempted after the singleton reference has been assigned, but before the singleton is initialized, so Thread 2 can return a reference to an uninitialized singleton instance.&lt;/p&gt;

&lt;p&gt;Since double-checked locking is not guaranteed to work, you must synchronize the entire getInstance() method. However, another alternative is simple, fast, and thread-safe.&lt;/p&gt;

&lt;h3 id=&quot;an-alternative-thread-safe-singleton-implementation&quot;&gt;An alternative thread-safe singleton implementation&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;java
public class Singleton {
   public final static Singleton INSTANCE = new Singleton();
   private Singleton() {
       // Exists only to defeat instantiation.
   }
}
&lt;/code&gt;
The preceding singleton implementation is thread-safe because static member variables created when declared are guaranteed to be created the first time they are accessed. You get a thread-safe implementation that automatically employs lazy instantiation, until the class file get loaded into memory, their is no instance instanciated at all.&lt;/p&gt;

&lt;p&gt;Of course, like nearly everything else, the preceding singleton is a compromise; if you use that implementation, you can’t change your mind and allow multiple singleton instances later on. With a more conservative singleton implementation, instances are obtained through a &lt;code&gt;getInstance()&lt;/code&gt; method, and you can change those methods to return a unique instance or one of hundreds. You can’t do the same with a public static member variable.
```java
public class Singleton {
   private final static Singleton INSTANCE = new Singleton();
   private Singleton() {
       // Exists only to defeat instantiation.
   }&lt;/p&gt;

&lt;p&gt;public static Singleton getInstance() {
       return INSTANCE;
   }
}
&lt;code&gt;
###Leveraging volatile to change Java Memory Model
We can recheck the instance again in synchronized block to ensure that only one instance of the Singleton object be instantiated, shown as below code:
&lt;/code&gt;java
public class LazySingleton {
    private static volatile LazySingleton instance;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// private constructor
private LazySingleton() {
}

public static LazySingleton getInstance() {
    if (instance == null) {
        synchronized (LazySingleton.class) {
            // Double check
            if (instance == null) {
                instance = new LazySingleton();
            }
        }
    }
    return instance;
} } ``` Please ensure to use &amp;lt;code&amp;gt;volatile&amp;lt;/code&amp;gt; keyword with instance variable otherwise you can run into out of order write error scenario, where reference of instance is returned before actually the object is constructed i.e. JVM has only allocated the memory and constructor code is still not executed. In this case, your other thread, which refer to uninitialized object may throw null pointer exception and can even crash the whole application.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although above code is the correct way to implement Singleton pattern, this is not recommended since it introduce extra complexity of code, which may introduce subtle bugs.&lt;/p&gt;

&lt;h3 id=&quot;classloaders&quot;&gt;Classloaders&lt;/h3&gt;
&lt;p&gt;Because multiple classloaders are commonly used in many situations—including servlet containers—you can wind up with multiple singleton instances no matter how carefully you’ve implemented your singleton classes. If you want to make sure the same classloader loads your singletons, you must specify the classloader yourself; for example:
&lt;code&gt;java
private static Class getClass(String classname) throws ClassNotFoundException {
    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
    if(classLoader == null)
        classLoader = Singleton.class.getClassLoader();
        return (classLoader.loadClass(classname));
    }
}
&lt;/code&gt;
The preceding method tries to associate the classloader with the current thread; if that classloader is null, the method uses the same classloader that loaded a singleton base class. The preceding method can be used instead of Class.forName().&lt;/p&gt;

&lt;h3 id=&quot;serialization2&quot;&gt;Serialization&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/h3&gt;
&lt;p&gt;If you serialize a singleton and then deserialize it twice, you will have two instances of your singleton, unless you implement the &lt;code&gt;readResolve()&lt;/code&gt; method, like this:
```java
public class Singleton implements java.io.Serializable {
    private static final long serialVersionUID = 1L;
    public static Singleton INSTANCE = new Singleton();&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private Singleton() {
    // Exists only to thwart instantiation.
}
   
private Object readResolve() {
    return INSTANCE;
} } ``` The previous singleton implementation returns the lone singleton instance from the readResolve() method; therefore, whenever the Singleton class is deserialized, it will return the same singleton instance. **Don&#39;t forget to add serial version id in this case, or you will get an exception during de-serialise process**.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;bill-pugh-solution3&quot;&gt;Bill Pugh solution&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/h3&gt;
&lt;p&gt;Bill Pugh was main force behind java memory model changes. His principle “Initialization-on-demand holder idiom” also uses static block but in different way. It suggest to use static inner class:
```java
public class BillPughSingleton {
    private BillPughSingleton() {
    }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static class LazyHolder {
    private static final BillPughSingleton INSTANCE = new BillPughSingleton();
}

public static BillPughSingleton getInstance() {
    return LazyHolder.INSTANCE;
} } ``` As you can see, until we need an instance, the LazyHolder class will not be initialized until required and you can still use other static members of BillPughSingleton class. This is the solution, i will recommend to use. I also use it in my all projects.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;using-enum&quot;&gt;Using Enum&lt;/h3&gt;
&lt;p&gt;As of release 1.5, there is a another approach to implementing singletons. which provide implicit support for thread safety and only one instance is guaranteed. This is also a good way to have singleton with minimum effort. Simply make an enum type with one element:
&lt;code&gt;java
// Enum singleton - the preferred approach
public enum LazyEnumSingleton {
    INSTANCE;
    public void otherMethods() { System.out.println(&quot;Other methods go&quot;); }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This approach is functionally equivalent to the public field approach, except that it is more concise, provides the serialization machinery for free, and provides an ironclad guarantee against multiple instantiation, even in the face of sophisticated serialization or reflection attacks. While this approach has yet to be widely adopted, &lt;strong&gt;a single-element enum type is the best way to implement a singleton&lt;/strong&gt;. JVM does the lazy-loading in a thread-safe manner. That’s why using this kind of lazy class loading is the preferred method—the JVM handles all the synchronization. We can see that with below little example code, try run it your self:
```java
public class LazyEnumSingletonExample {
    public static void main(String[] args) throws InterruptedException {
        System.out.println(“Accessing enum for the first time.”);
        LazyEnumSingleton lazy = LazyEnumSingleton.INSTANCE;
        System.out.println(“Done.”);
    }
}&lt;/p&gt;

&lt;p&gt;enum LazyEnumSingleton {
    INSTANCE;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static {
    System.out.println(&quot;Initialize in process...&quot;);
} } ``` Output of the code: ``` Accessing enum for the first time. Initialize in process... Done. ``` In Java, enum can hold state, which makes the single-element enum type the perfect condidate for Singleton pattern, see below code: ```java enum LazyEnumSingletonWithState {
INSTANCE(&quot;State&quot;) {

    @Override
    public String toOverwrittenOps(String str) {
        return str + this.state;
    }
};

private String state;

private LazyEnumSingletonWithState(String state) {
    this.state = state;
}

public String otherOps(String arg) {
    return arg + state;
}

@Override
public String toString() {
    return this.state;
}

public abstract String toOverwrittenOps(String str); } ```
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;preventing-privileged-clients&quot;&gt;Preventing privileged clients&lt;/h3&gt;
&lt;p&gt;As we mentioned before, single pattern can be broken with reflection, as below code shown:
&lt;code&gt;java
public static void main(String[] args) throws Exception {
    Singleton s1 = Singleton.getInstance();
    Class clazz = Singleton.class;
    Constructor cons = clazz.getDeclaredConstructor();
    cons.setAccessible(true);
    // Another instance can be instantiated now.
    Singleton s2 = (Singleton) cons.newInstance();
}
&lt;/code&gt;
It’s easy to get over this issue:
```java
public class PrivilegedSingleton {
    private static final PrivilegedSingleton INSTANCE = new PrivilegedSingleton();&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private PrivilegedSingleton() {

    // Check if we already have an instance
    if (INSTANCE != null) {
        throw new IllegalStateException(&quot;Singleton instance already created.&quot;);
    }
}

public static PrivilegedSingleton getInstance() {
    return INSTANCE;
} } ``` Sometimes, your IDE may remind you that the &amp;lt;code&amp;gt;INSTANCE&amp;lt;/code&amp;gt; variable will never be null, don&#39;t rely on that, IDE can make mistake too.
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.javaworld.com/article/2073352/core-java/simply-singleton.html&quot;&gt;Simply Singleton: Navigate the deceptively simple Singleton pattern&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.amazon.com/Effective-Java-Edition-Joshua-Bloch/dp/0321356683&quot;&gt;Effective Java, 2nd edition&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://howtodoinjava.com/2012/10/22/singleton-design-pattern-in-java/&quot;&gt;Singleton design pattern in Java&lt;/a&gt; &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 07 Apr 2014 06:54:11 +0800</pubDate>
        <link>http://codethoughts.info/java/2014/04/07/singleton-pattern-in-java/</link>
        <guid isPermaLink="true">http://codethoughts.info/java/2014/04/07/singleton-pattern-in-java/</guid>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>service provider frameworks</title>
        <description>&lt;h3 id=&quot;overview&quot;&gt;Overview&lt;/h3&gt;
&lt;p&gt;In &lt;a href=&quot;http://www.amazon.com/Effective-Java-Edition-Joshua-Bloch/dp/0321356683&quot;&gt;Effective Java, second edition&lt;/a&gt;, the author mentioned a pattern called Service Provider frameworks. The author wrote:
&amp;gt; A service provider framework is a system in which multiple service providers implement a service, and the system makes the implementations available to its clients, decoupling them from the implementations.&lt;/p&gt;

&lt;p&gt;In this blog post, I’ll talk about the details of Service Provider Frameworks thru it’s application in JDK, to be specific, in JDBC and Codec lookup.
&lt;!--more--&gt;
&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;As the author said, there are three essential components of a service provider framework: a &lt;strong&gt;service interface&lt;/strong&gt;, which providers implement; a &lt;strong&gt;provider registration API&lt;/strong&gt;, which the system uses to register implementations, giving clients access to them; and a &lt;strong&gt;service access API&lt;/strong&gt;, which clients use to obtain an instance of the service. The service access API typically allows but does not require the client to specify some criteria for choosing a provider. In the absence of such a specification, the API returns an instance of a default implementation. The service access API is the “flexible static factory” that forms the basis of the service provider framework.&lt;/p&gt;

&lt;p&gt;An optional fourth component of a service provider framework is a &lt;strong&gt;service provider interface&lt;/strong&gt;, which providers implement to create instances of their service implementation. &lt;em&gt;In the absence of a service provider interface, implementations are registered by class name and instantiated reflectively&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;service-provider-frameworks-in-jdbc&quot;&gt;Service Provider Frameworks in JDBC&lt;/h3&gt;
&lt;p&gt;In the case of &lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/jdbc/index.html&quot;&gt;JDBC&lt;/a&gt;, &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/sql/Connection.html&quot;&gt;Connection&lt;/a&gt; plays the part of the service interface, &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/sql/DriverManager.html#registerDriver\(java.sql.Driver\)&quot;&gt;DriverManager.registerDriver&lt;/a&gt; is the provider registration API, &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/sql/DriverManager.html#getConnection\(java.lang.String\)&quot;&gt;DriverManager.getConnection&lt;/a&gt; is the service access API, and &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/sql/Driver.html&quot;&gt;Driver&lt;/a&gt; is the service provider interface.&lt;/p&gt;

&lt;p&gt;Usually in order to use JDBC, you should execute below code:
```java
      // Register JDBC driver, before JDBC 4.0 only
      Class.forName(“com.mysql.jdbc.Driver”);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  // Open a connection
  System.out.println(&quot;Connecting to database...&quot;);
  conn = DriverManager.getConnection(DB_URL,USER,PASS); ``` The &amp;lt;code&amp;gt;Class.forname(&quot;com.mysql.jdbc.Driver&quot;)&amp;lt;/code&amp;gt; can be eliminated after JDBC 4.0, as you can see in the document of [DriverManager](http://docs.oracle.com/javase/7/docs/api/java/sql/DriverManager.html) &amp;gt; The DriverManager methods getConnection and getDrivers have been enhanced to support the Java Standard Edition [Service Provider](http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Service%20Provider) mechanism. JDBC 4.0 Drivers must include the file META-INF/services/java.sql.Driver. This file contains the name of the JDBC drivers implementation of java.sql.Driver. For example, to load the my.sql.Driver class, the META-INF/services/java.sql.Driver file would contain the entry: &amp;gt; my.sql.Driver &amp;gt; Applications no longer need to explicitly load JDBC drivers using &amp;lt;code&amp;gt;Class.forName()&amp;lt;/code&amp;gt;. Existing programs which currently load JDBC drivers using Class.forName() will continue to work without modification.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;service-provider-mechanism2&quot;&gt;Service Provider mechanism&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/h3&gt;
&lt;p&gt;Now let’s dig deeper into the &lt;strong&gt;Service Provider mechanism&lt;/strong&gt; and &lt;strong&gt;Service Provider configuration file&lt;/strong&gt;, you can find it &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Service%20Provider&quot;&gt;here&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;Files in the &lt;code&gt;META-INF/services&lt;/code&gt; directory are service provider configuration files. A service is a well-known set of interfaces and (usually abstract) classes. A service provider is a specific implementation of a service. The classes in a provider typically implement the interfaces and subclass the classes defined in the service itself. Service providers may be installed in an implementation of the Java platform in the form of extensions, that is, jar files placed into any of the usual extension directories. Providers may also be made available by adding them to the applet or application class path or by some other platform-specific means.&lt;/p&gt;

&lt;p&gt;A service is represented by an abstract class. A provider of a given service contains one or more concrete classes that extend this service class with data and code specific to the provider. This provider class will typically not be the entire provider itself but rather a proxy that contains enough information to decide whether the provider is able to satisfy a particular request together with code that can create the actual provider on demand. The details of provider classes tend to be highly service-specific; no single class or interface could possibly unify them, so no such class has been defined. The only requirement enforced here is that provider classes must have a zero-argument constructor so that they may be instantiated during lookup.&lt;/p&gt;

&lt;h3 id=&quot;provider-configuration-file&quot;&gt;Provider-Configuration File&lt;/h3&gt;
&lt;p&gt;A service provider identifies itself by placing a provider-configuration file in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;. The file’s name should consist of the fully-qualified name of the abstract service class. The file should contain a newline-separated list of unique concrete provider-class names. Space and tab characters, as well as blank lines, are ignored. The comment character is ‘#’ (0x23); on each line all characters following the first comment character are ignored. The file must be encoded in UTF-8.&lt;/p&gt;

&lt;h3 id=&quot;example-of-service-provider-mechanism&quot;&gt;Example of Service Provider mechanism&lt;/h3&gt;
&lt;p&gt;Suppose we have a service class named &lt;code&gt;java.io.spi.CharCodec&lt;/code&gt;. It has two abstract methods:
&lt;code&gt;java
public abstract CharEncoder getEncoder(String encodingName);
public abstract CharDecoder getDecoder(String encodingName);
&lt;/code&gt;
Each method returns an appropriate object or null if it cannot translate the given encoding. Typical CharCodec providers will support more than one encoding.&lt;/p&gt;

&lt;p&gt;If &lt;code&gt;sun.io.StandardCodec&lt;/code&gt; is a provider of the &lt;code&gt;CharCodec&lt;/code&gt; service then its jar file would contain the file &lt;code&gt;META-INF/services/java.io.spi.CharCodec&lt;/code&gt;. This file would contain the single line:
&lt;code&gt;sun.io.StandardCodec    # Standard codecs for the platform&lt;/code&gt;
To locate an encoder for a given encoding name, the internal I/O code would do something like this:
&lt;code&gt;java
   CharEncoder getEncoder(String encodingName) {
       Iterator ps = Service.providers(CharCodec.class);
       while (ps.hasNext()) {
           CharCodec cc = (CharCodec)ps.next();
           CharEncoder ce = cc.getEncoder(encodingName);
           if (ce != null)
               return ce;
       }
       return null;
   }
&lt;/code&gt;
The provider-lookup mechanism always executes in the security context of the caller. Trusted system code should typically invoke the methods in this class from within a privileged security context.&lt;/p&gt;

&lt;h3 id=&quot;how-service-provider-mechanism-works-in-jdbc&quot;&gt;How Service Provider mechanism works in JDBC&lt;/h3&gt;
&lt;p&gt;Now we can draw the conclusion that with service provider configuration file, during jar loading, the loading thread will find the configuration first, then register the services by name from the configuration file. The service configuration file contains the name of the JDBC driver’s implementation of &lt;code&gt;java.sql.Driver&lt;/code&gt;. For example, to load the JDBC driver to connect to a Apache Derby database, the &lt;code&gt;META-INF/services/java.sql.Driver&lt;/code&gt; file would contain the following entry:
&lt;code&gt;org.apache.derby.jdbc.EmbeddedDriver&lt;/code&gt;. Then it will call &lt;code&gt;DriverManager.registerDriver&lt;/code&gt; to register specific Database driver automatically, so you don’t need to call &lt;code&gt;Class.forName()&lt;/code&gt; yourself. After that, you can access the service thru &lt;strong&gt;Service Access Interface&lt;/strong&gt;, &lt;code&gt;java.sql.DriverManager.getConnection&lt;/code&gt; to get the service, which in this case, is a implementation of &lt;code&gt;java.sql.Connection&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;However, before JDBC 4.0, you don’t have the facility, you have to register database driver manually by calling &lt;code&gt;Class.forName&lt;/code&gt; to register the driver before accessing the service interface.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.amazon.com/Effective-Java-Edition-Joshua-Bloch/dp/0321356683&quot;&gt;Effective Java, second edition&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Service%20Provider&quot;&gt;jar file specification#Service Provider&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 06 Apr 2014 22:39:44 +0800</pubDate>
        <link>http://codethoughts.info/java/2014/04/06/service-provider-frameworks-pattern/</link>
        <guid isPermaLink="true">http://codethoughts.info/java/2014/04/06/service-provider-frameworks-pattern/</guid>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>Enum, EnumSet, and EnumMap sample</title>
        <description>&lt;p&gt;&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html&quot;&gt;Enum&lt;/a&gt; was introduced in Java 1.5, although the Java enum can be used with any Java collection, its full power is best leveraged when used with the &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/EnumMap.html&quot;&gt;EnumMap&lt;/a&gt; and &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/EnumSet.html&quot;&gt;EnumSet&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Why should you use &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/EnumMap.html&quot;&gt;EnumMap&lt;/a&gt; and &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/EnumSet.html&quot;&gt;EnumSet&lt;/a&gt;, rather than their counterparts &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt; and &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html&quot;&gt;HashSet&lt;/a&gt;. The primary reason boil down to performance and memory usage advantage. Let’s see their JavaDoc firstly.
&lt;!-- more --&gt;
Document of &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/EnumMap.html&quot;&gt;EnumMap&lt;/a&gt;:
&amp;gt; A specialized Map implementation for use with enum type keys. All of the keys in an enum map must come from a single enum type that is specified, explicitly or implicitly, when the map is created. Enum maps are represented internally as arrays. This representation is extremely compact and efficient.
&amp;gt; …
&amp;gt; Implementation note: All basic operations execute in constant time. They are likely (though not guaranteed) to be faster than their HashMap counterparts.&lt;/p&gt;

&lt;p&gt;Document of &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/EnumSet.html&quot;&gt;EnumSet&lt;/a&gt;:
&amp;gt; A specialized Set implementation for use with enum types. All of the elements in an enum set must come from a single enum type that is specified, explicitly or implicitly, when the set is created. Enum sets are represented internally as bit vectors. This representation is extremely compact and efficient. The space and time performance of this class should be good enough to allow its use as a high-quality, typesafe alternative to traditional int-based “bit flags.” Even bulk operations (such as containsAll and retainAll) should run very quickly if their argument is also an enum set.
&amp;gt; …
&amp;gt; Implementation note: All basic operations execute in constant time. They are likely (though not guaranteed) to be much faster than their HashSet counterparts. Even bulk operations execute in constant time if their argument is also an enum set.&lt;/p&gt;

&lt;p&gt;Both of &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/EnumMap.html&quot;&gt;EnumMap&lt;/a&gt; and &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/EnumSet.html&quot;&gt;EnumSet&lt;/a&gt; belong to &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html&quot;&gt;Java Collections Framework&lt;/a&gt;, so they’re easy to use because as Java developer, you should familiar with &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html&quot;&gt;Java Collections Framework&lt;/a&gt;; in the mean time, they’re compact and efficient,  they’re also enum-powered collections which are easy to use, you can see that in below sample code.&lt;/p&gt;

&lt;p&gt;First, let’s see an enum deifiniation:
```java
import java.util.EnumSet;&lt;/p&gt;

&lt;p&gt;public enum Weekday {
    MONDAY {
        @Override
        public String getDetail() {
            return “Monday”;
        }
    },&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TUESDAY {
    @Override
    public String getDetail() {
        return &quot;Tuesday&quot;;
    }
},

WEDNESDAY {
    @Override
    public String getDetail() {
        return &quot;Wednesday&quot;;
    }
},

THURSDAY {
    @Override
    public String getDetail() {
        return &quot;Thursday&quot;;
    }
},

FRIDAY {
    @Override
    public String getDetail() {
        return &quot;Friday&quot;;
    }
},

SATURDAY {
    @Override
    public String getDetail() {
        return &quot;Saturday&quot;;
    }
},

SUNDAY {
    @Override
    public String getDetail() {
        return &quot;Sunday&quot;;
    }
};

public abstract String getDetail();

public static final EnumSet&amp;lt;Weekday&amp;gt; WORKDAYS = EnumSet.range(MONDAY, FRIDAY);

public final boolean isWorkday() {
    return WORKDAYS.contains(this);
}

public static final EnumSet&amp;lt;Weekday&amp;gt; THE_WHOLE_WEEK = EnumSet.allOf(Weekday.class); } ``` You can see that one of interesting feature of Java enum is that you can declare **abstract methods**, in above example getDetail() is the abstract method and all the enum fields have implemented it. You can check some other details of Java enum [here](http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let’s move on to our sample code of &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/EnumMap.html&quot;&gt;EnumMap&lt;/a&gt; and &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/EnumSet.html&quot;&gt;EnumSet&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;```java
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.Map;&lt;/p&gt;

&lt;p&gt;public final class EnumSetExample {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void main(String... args) {
    System.out.println(&quot;Work Schedule:&quot;);

    for (Weekday weekday : Weekday.THE_WHOLE_WEEK) {
        String action = weekday.isWorkday()
                ? &quot;have to work&quot;
                : &quot;can relax&quot;;
        // Enum.ordinal starts with 0
        System.out.println(String.format(&quot;%d. On %s you &quot; + action + &quot;.&quot;, weekday.ordinal() + 1, weekday));
    }

    System.out.println(&quot;Do I have to work the whole week?&quot;);

    String result = Weekday.WORKDAYS.containsAll(Weekday.THE_WHOLE_WEEK)
            ? &quot;Yes, unfortunately.&quot;
            : &quot;Certainly not.&quot;;
    System.out.println(result);

    final EnumSet&amp;lt;Weekday&amp;gt; weekend = Weekday.THE_WHOLE_WEEK.clone();
    weekend.removeAll(Weekday.WORKDAYS);

    System.out.println(String.format(&quot;The weekend is %d days long.&quot;, weekend.size()));

    // EnumMap example
    EnumMap&amp;lt;Weekday, String&amp;gt; eMap = new EnumMap&amp;lt;&amp;gt;(Weekday.class);
    for (Weekday day : Weekday.THE_WHOLE_WEEK) {
        eMap.put(day, day.getDetail());
    }

    System.out.println(&quot;Print weekdays:&quot;);
    for (Map.Entry&amp;lt;Weekday, String&amp;gt; entry : eMap.entrySet()) {
        System.out.println(entry.getKey() + &quot;\t&quot; + entry.getValue());
    }
} } ``` You can run above source code by yourself, check the result then find related API of [EnumMap](http://docs.oracle.com/javase/7/docs/api/java/util/EnumMap.html) and [EnumSet](http://docs.oracle.com/javase/7/docs/api/java/util/EnumSet.html). The above source code makes use of the following features in Java.[^1]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;enum keyword&lt;/li&gt;
  &lt;li&gt;enum custom methods&lt;/li&gt;
  &lt;li&gt;enum toString() method&lt;/li&gt;
  &lt;li&gt;EnumSet#range()&lt;/li&gt;
  &lt;li&gt;EnumSet#allOf()&lt;/li&gt;
  &lt;li&gt;EnumSet#clone()&lt;/li&gt;
  &lt;li&gt;EnumSet#removeAll()&lt;/li&gt;
  &lt;li&gt;EnumSet#size()&lt;/li&gt;
  &lt;li&gt;EnumSet iteration&lt;/li&gt;
  &lt;li&gt;String#format()&lt;/li&gt;
  &lt;li&gt;EnumMap construction and iteration&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 06 Apr 2014 20:50:38 +0800</pubDate>
        <link>http://codethoughts.info/java/2014/04/06/enum-enumset-enummap-sample/</link>
        <guid isPermaLink="true">http://codethoughts.info/java/2014/04/06/enum-enumset-enummap-sample/</guid>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>solutions to scala for the impatient - chapter5</title>
        <description>&lt;p&gt;1. Improve the Counter class in Section 5.1, “Simple Classes and Parameterless Methods,” on page 49 so that it doesn’t turn negative at &lt;code&gt;Int.MaxValue&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;```scala
class Counter {
  private var value = 0&lt;/p&gt;

&lt;p&gt;def increment() {
    if ((value + 1) &amp;lt; Int.MaxValue)
      value += 1
  }
  def current = value
}
```
&lt;!--more--&gt;
2. Write a class &lt;code&gt;BankAccount&lt;/code&gt; with methods &lt;code&gt;deposit&lt;/code&gt; and &lt;code&gt;withdraw&lt;/code&gt;, and a read-only property &lt;code&gt;balance&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;```scala
class BankAccount(private var _balance: Double = 0.0) {&lt;/p&gt;

&lt;p&gt;def deposit(amount: Double) = {
    _balance += amount
  }&lt;/p&gt;

&lt;p&gt;def withdraw(amount: Double) = {
    if (balance &amp;gt; amount) {
      _balance -= amount
      true
    } else {
      false
    }
  }&lt;/p&gt;

&lt;p&gt;def balance = _balance
}
```&lt;/p&gt;

&lt;p&gt;3. Write a class &lt;code&gt;Time&lt;/code&gt; with read-only properties &lt;code&gt;hours&lt;/code&gt; and &lt;code&gt;minutes&lt;/code&gt; and a method &lt;code&gt;before(other: Time): Boolean&lt;/code&gt; that checks whether this time comes before the other. A &lt;code&gt;Time&lt;/code&gt; object should be constructed as &lt;code&gt;new Time(hrs, min)&lt;/code&gt;, where hrs is in military time format (between 0 and 23).
```scala
class Time(val hours: Int, val minutes: Int) {
  // Validations goes here.
  if (hours &amp;gt; 23 || hours &amp;lt; 0) {
    throw new IllegalArgumentException(“should larger than 0 or smaller than 23”)
  }&lt;/p&gt;

&lt;p&gt;if (minutes &amp;lt; 0 || minutes &amp;gt; 59) {
    throw new IllegalArgumentException(“should larger than 0 or small than 59”)
  }&lt;/p&gt;

&lt;p&gt;def before(other: Time): Boolean = {
    if (hours &amp;lt; other.hours) {
      if (minutes &amp;lt;  other.minutes) {
        return true
      }
    }
    false
  }
}
```&lt;/p&gt;

&lt;p&gt;4. Reimplement the Time class from the preceding exercise so that the internal representation is the number of minutes since midnight (between 0 and 24 × 60 – 1). Do not change the public interface. That is, client code should be unaffected by your change.&lt;/p&gt;

&lt;p&gt;```scala
class Time(private val _hours: Int, private val _minutes: Int) {&lt;/p&gt;

&lt;p&gt;if (hours &amp;gt; 23 || hours &amp;lt; 0) {
    throw new IllegalArgumentException(“should larger than 0 or smaller than 23”)
  }&lt;/p&gt;

&lt;p&gt;if (minutes &amp;lt; 0 || minutes &amp;gt; 59) {
    throw new IllegalArgumentException(“should larger than 0 or small than 59”)
  }&lt;/p&gt;

&lt;p&gt;private val _total_minutes = _hours * 60 + _minutes&lt;/p&gt;

&lt;p&gt;def minutes = _minutes
  def hours = _hours&lt;/p&gt;

&lt;p&gt;def before(other: Time): Boolean = {
    if (_total_minutes &amp;lt; other._total_minutes)
      true
    else
      false
  }
}
```&lt;/p&gt;

&lt;p&gt;5. Make a class &lt;code&gt;Student&lt;/code&gt; with read-write JavaBeans properties name (of type &lt;code&gt;String&lt;/code&gt;) and id (of type &lt;code&gt;Long&lt;/code&gt;). What methods are generated? (Use javap to check.) Can you call the JavaBeans getters and setters in Scala Should you?&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;
```scala
import scala.reflect.BeanProperty&lt;/p&gt;

&lt;p&gt;class Student(@BeanProperty var name: String, @BeanProperty var id: Long) {&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;object Main extends App {
  val human = new Student(“Dave Grohl”, 1337)&lt;/p&gt;

&lt;p&gt;// You can call the JavaBeans getter and setter, just like this
  human.setName(“Kurt Cobain”)
  human.setId(5000)&lt;/p&gt;

&lt;p&gt;// But why would you, when the Scala-esque methods are generated?
  human.name = “Krist Novoselic”
  human.id = 5001
}
```&lt;/p&gt;

&lt;p&gt;The output of javap as below:
&lt;code&gt;
$ javap Student
// Compiled from &quot;ch5_exercises.scala&quot;
public class Student {
  public java.lang.String name();
  public void name_$eq(java.lang.String);
  public void setName(java.lang.String);
  public long id();
  public void id_$eq(long);
  public void setId(long);
  public java.lang.String getName();
  public long getId();
  public Student(java.lang.String, long);
}
&lt;/code&gt;
You can see that Scala generate getters/setters for you, as well as &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;name\_=&lt;/code&gt;, &lt;code&gt;id&lt;/code&gt;, and &lt;code&gt;id_=&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;6. In the &lt;code&gt;Person&lt;/code&gt; class of Section 5.1, “Simple Classes and Parameterless Methods,” on page 49, provide a primary constructor that turns negative ages to 0.
```scala
class Person(val _name: String, var _age: Int) {
  if (_age &amp;lt; 0)
    _age = 0&lt;/p&gt;

&lt;p&gt;def age = &lt;em&gt;age
  def age&lt;/em&gt;=(new_age: Int) {
    if (new_age &amp;gt; _age)
      _age = new_age
  }
}
```&lt;/p&gt;

&lt;p&gt;7. Write a class &lt;code&gt;Person&lt;/code&gt; with a primary constructor that accepts a string containing a first name, a space, and a last name, such as &lt;code&gt;new Person(&quot;Fred Smith&quot;)&lt;/code&gt;. Supply read-only properties &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;lastName&lt;/code&gt;. Should the primary constructor parameter be a var, a val, or a plain parameter? Why?
&lt;code&gt;scala
class Person(val fullname: String) {
  if (fullname == null || fullname.split(&quot; &quot;).size &amp;lt; 2)
    throw new IllegalArgumentException(&quot;Name is not be in format of first_name last_name&quot;)
  private val tmp_name = fullname.split(&quot; &quot;)
  val firstName = tmp_name(0)
  val lastName = tmp_name(1)
}
&lt;/code&gt;
As the primary constructor parameter name suggests, it should be a val to prevent it from being changed, at the same time, it should have a public getter method so that others can get the person’s full name.&lt;/p&gt;

&lt;p&gt;8. Make a class &lt;code&gt;Car&lt;/code&gt; with read-only properties for &lt;code&gt;manufacturer&lt;/code&gt;, &lt;code&gt;model name&lt;/code&gt;, and &lt;code&gt;model year&lt;/code&gt;, and a read-write property for the &lt;code&gt;license plate&lt;/code&gt;. Supply four constructors. All require the &lt;code&gt;manufacturer&lt;/code&gt; and &lt;code&gt;model name&lt;/code&gt;. Optionally, &lt;code&gt;model year&lt;/code&gt; and &lt;code&gt;license plate&lt;/code&gt; can also be specified in the constructor. If not, the &lt;code&gt;model year&lt;/code&gt; is set to -1 and the &lt;code&gt;license plate&lt;/code&gt; to the empty string. Which constructor are you choosing as the primary constructor? Why?&lt;/p&gt;

&lt;p&gt;We only need primary constructor here, it can take default parameters, which we can leverage to eliminate the auxiliary constructor, as below code shown:
&lt;code&gt;scala
class Car(val manufacturer: String, 
    val modelName: String, 
    val modelYear: Int = -1, 
    var licensePlate: String = &quot;&quot;) {
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;9. Reimplement the class of the preceding exercise in Java, C#, or C++ (your choice). How much shorter is the Scala class?&lt;/p&gt;

&lt;p&gt;Equivalent Java code as below: 
```java
public class Car {
    private String manufacturer;
    private String modelName;
    private int modelYear;
    private String licensePlate;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public Car(String manufacturer, String modelName, int modelYear, String licensePlate) {
    this.manufacturer = manufacturer;
    this.modelName = modelName;
    this.modelYear = modelYear;
    this.licensePlate = licensePlate;
}

public Car(String manufacturer, String modelName) {
    this(manufacturer, modelName, -1, &quot;&quot;);
}

public Car(String manufacturer, String modelName, int modelYear) {
    this(manufacturer, modelName, modelYear, &quot;&quot;);
}

public Car(String manufacturer, String modelName, String licensePlate) {
    this(manufacturer, modelName, -1, licensePlate);
}

public String getManufacturer() {
    return manufacturer;
}

public String getModelName() {
    return modelName;
}

public int getModelYear() {
    return modelYear;
}

public String getLicensePlate() {
    return licensePlate;
}

public void setLicensePlate(String licensePlate) {
    this.licensePlate = licensePlate;
} }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;10. Consider the class
&lt;code&gt;scala
class Employee(val name: String, var salary: Double) {
  def this() { this(&quot;John Q. Public&quot;, 0.0) }
}
&lt;/code&gt;
Rewrite it to use explicit fields and a default primary constructor. Which form do you prefer? Why?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;scala
class Employee(val name: String = &quot;John Q. Public&quot;, var salary: Double = 0.0) {}
&lt;/code&gt;
I prefer to above code, using primary constructor with default parameters, also there’s no explicit getters/setters. After falling love with Ruby programming language, I prefer to any coding style that can lead to concise and short code, most of time, short code is easy to maintain, to test and to develop.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://bitbucket.org/McDamon/scalaimpatient/src/4a11167459b2/ch05/answers.txt&quot;&gt;Scala for the Impatient, by McDamon&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 09 Mar 2014 20:03:35 +0800</pubDate>
        <link>http://codethoughts.info/scala/2014/03/09/scala-for-the-impatient-chapter5/</link>
        <guid isPermaLink="true">http://codethoughts.info/scala/2014/03/09/scala-for-the-impatient-chapter5/</guid>
        
        
        <category>scala</category>
        
      </item>
    
      <item>
        <title>solutions to scala for the impatient - chapter4</title>
        <description>&lt;p&gt;1. Set up a map of prices for a number of gizmos that you covet. Then produce a second map with the same keys and the prices at a 10 percent discount.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;scala
val books = Map(&quot;Scala for the Impatient&quot; -&amp;gt; 30, &quot;Ruby under a Microscope&quot; -&amp;gt; 40, &quot;Ruby Cookbook&quot; -&amp;gt; 35)
val discounted = for((b, p) &amp;lt;- books) yield (b, p * 0.9)
&lt;/code&gt;
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;2. Write a program that reads words from a file. Use a mutable map to count how often each word appears. To read the words, simply use a &lt;code&gt;java.util.Scanner&lt;/code&gt;:
&lt;code&gt;scala
val in = new java.util.Scanner(new java.io.File(&quot;myfile.txt&quot;))
while (in.hasNext()) 
	process in.next()
&lt;/code&gt;
Or look at Chapter 9 for a Scalaesque way.
At the end, print out all words and their counts.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;scala
def count_words(file: String): Unit = {
	val container = collection.mutable.Map[String, Int]()
	val in = new java.util.Scanner(new java.io.File(file))
	while (in.hasNext()) {
		val word =  in.next()
		if (container.contains(word))
			container(word) += 1
		else
			container(word) = 1
	}
	for ((k, v) &amp;lt;- container)
		println(k + &quot;: &quot; + v)
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3. Repeat the preceding exercise with an immutable map.
&lt;code&gt;scala
def count_words(file: String): Unit = {
	var container = Map[String, Int]()
	val in = new java.util.Scanner(new java.io.File(file))
	while (in.hasNext()) {
		val word = in.next()
		container = container + (word -&amp;gt; (container.getOrElse(word, 0) + 1))
	}
	println(container)
}
&lt;/code&gt;
Or we can achieve nearly the same more Scalaesque(the result is little different, but you get the idea)&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;:
```scala
import scala.io.Source&lt;/p&gt;

&lt;p&gt;def count_words(file: String): Unit = {
	val source = Source.fromFile(file)
	val words = for (word &amp;lt;- source.getLines.toArray) yield word
	val wordCounts = for (word &amp;lt;- words.distinct) yield {
  		(word, words.count(_ == word))
	}
	val wordCountsMap = wordCounts.toMap
	println(wordCountsMap)
}
```&lt;/p&gt;

&lt;p&gt;4. Repeat the preceding exercise with a sorted map, so that the words are printed in sorted order.
&lt;code&gt;scala
def count_words(file: String): Unit = {
	var container = collection.immutable.SortedMap[String, Int]()
	val in = new java.util.Scanner(new java.io.File(file))
	while (in.hasNext()) {
		val word = in.next()
		container = container + (word -&amp;gt; (container.getOrElse(word, 0) + 1))
	}
	println(container)
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;5. Repeat the preceding exercise with a &lt;code&gt;java.util.TreeMap&lt;/code&gt; that you adapt to the Scala API.
&lt;code&gt;scala
def count_words(file: String): Unit = {
	val container = new java.util.TreeMap[String, Int]
	val in = new java.util.Scanner(new java.io.File(file))
	while (in.hasNext()) {
		val word =  in.next()
		if (container.containsKey(word))
			container.put(word, container.get(word) + 1)
		else
			container.put(word, 1)
	}
	println(container)
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;6. Define a linked hash map that maps “Monday” to &lt;code&gt;java.util.Calendar.MONDAY&lt;/code&gt;, and similarly for the other weekdays. Demonstrate that the elements are visited in insertion order.
```scala
val daysOfTheWeek = LinkedHashMap(“Monday” -&amp;gt; java.util.Calendar.MONDAY,
    “Tuesday” -&amp;gt; java.util.Calendar.TUESDAY,
    “Wednesday” -&amp;gt; java.util.Calendar.WEDNESDAY,
    “Thursday” -&amp;gt; java.util.Calendar.THURSDAY,
    “Friday” -&amp;gt; java.util.Calendar.FRIDAY,
    “Saturday” -&amp;gt; java.util.Calendar.SATURDAY,
    “Sunday” -&amp;gt; java.util.Calendar.SUNDAY)&lt;/p&gt;

&lt;p&gt;println(daysOfTheWeek)
```&lt;/p&gt;

&lt;p&gt;7. Print a table of all Java properties, like this:
&lt;code&gt;
java.runtime.name             | Java(TM) SE Runtime Environment
sun.boot.library.path         | /home/apps/jdk1.6.0_21/jre/lib/i386
java.vm.version               | 17.0-b16
java.vm.vendor                | Sun Microsystems Inc.
java.vendor.url               | http://java.sun.com/
path.separator                | :
java.vm.name                  | Java HotSpot(TM) Server VM
&lt;/code&gt;
You need to find the length of the longest key before you can print the table.
&lt;code&gt;scala
import scala.collection.JavaConversions.propertiesAsScalaMap
val props: scala.collection.Map[String, String] = System.getProperties
val len = props.keys.maxBy(_.length).length // java.vm.specification.version
for ((k, v) &amp;lt;- props) printf(&quot;%-&quot;+ len + &quot;s|%s\n&quot;, k, v)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;8. Write a function &lt;code&gt;min_max(values: Array[Int])&lt;/code&gt; that returns a pair containing the smallest and largest values in the array.
&lt;code&gt;scala
def min_max(values: Array[Int]): Tuple2[Int, Int] = {
	(values.min, values.max)
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;9. Write a function lt_eq_gt(values: Array[Int], v: Int) that returns a triple containing the counts of values less than v, equal to v, and greater than v.
&lt;code&gt;scala
def lt_eg_gt(values: Array[Int], v: Int): Tuple3[Int, Int, Int] = {
	(values.count(_ &amp;lt; v), values.count(_ == v), values.count(_&amp;gt; v))
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;10. What happens when you zip together two strings, such as &lt;code&gt;&quot;Hello&quot;.zip(&quot;World&quot;)&lt;/code&gt;? Come up with a plausible use case.
&lt;code&gt;scala
// produce: scala.collection.immutable.IndexedSeq[(Char, Char)] = Vector((H,W), (e,o), (l,r), (l,l), (o,d))
&quot;Hello&quot;.zip(&quot;World&quot;) 
&lt;/code&gt;
From above code we can see that the zip of two String will produce a immutable Vector, which contains Tuples. The Tuples contains a pair of characters in the same position. A possible use case is to produce a immutable map with left characters as keys and right side characters as values, you can transfer the zipped characters to a immutable map via:
&lt;code&gt;scala
val map = &quot;Hello&quot;.zip(&quot;World&quot;).toMap
&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://bitbucket.org/McDamon/scalaimpatient/src/4a11167459b2/ch04/answers.txt&quot;&gt;Scala for the Impatient solutions, by McDamon&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 08 Mar 2014 20:49:44 +0800</pubDate>
        <link>http://codethoughts.info/scala/2014/03/08/scala-for-the-impatient-chapter4/</link>
        <guid isPermaLink="true">http://codethoughts.info/scala/2014/03/08/scala-for-the-impatient-chapter4/</guid>
        
        
        <category>scala</category>
        
      </item>
    
      <item>
        <title>Solutions to Scala for the Impatient - Chapter3</title>
        <description>&lt;p&gt;In this blog post, I will continue to post the solutions to &lt;a href=&quot;http://www.amazon.com/Scala-Impatient-Cay-S-Horstmann/dp/0321774094&quot;&gt;Scala for the Impatient&lt;/a&gt;, Chapter 3 as book notes, hopes it could help if you’re reading the book too. Without further ado, let’s see the solutions in Scala.&lt;/p&gt;

&lt;p&gt;1. Write a code snippet that sets a to an array of n random integers between 0 (inclusive) and n (exclusive).
```scala&lt;/p&gt;

&lt;p&gt;import scala.util.Random&lt;/p&gt;

&lt;p&gt;def random_arr(n: Int) = {
	Array.fill(n) {Random.nextInt(n)}
}
```
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;2. Write a loop that swaps adjacent elements of an array of integers. For example, &lt;code&gt;Array(1, 2, 3, 4, 5)&lt;/code&gt; becomes &lt;code&gt;Array(2, 1, 4, 3, 5)&lt;/code&gt;.
&lt;code&gt;scala
	val arr = Array(1, 2, 3, 4, 5)
	arr.grouped(2).flatMap {
		case Array(x, y) =&amp;gt; Array(y, x)
		case Array(x) =&amp;gt; Array(x)
	}.toArray
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3. Repeat the preceding assignment, but produce a new array with the swapped values. Use &lt;code&gt;for/yield&lt;/code&gt;&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;.
&lt;code&gt;scala
	val arr = Array(1, 2, 3, 4, 5)
	val new_arr = for (i &amp;lt;- 0 until arr.length) yield {
  	if (i % 2 == 0 &amp;amp;&amp;amp; i &amp;lt; arr.length - 1)
  	arr(i + 1)
  	else if (i % 2 != 0 &amp;amp;&amp;amp; i &amp;gt; 0)
   		arr(i - 1)
  	else
   		arr(i)
   }
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;4. Given an array of integers, produce a new array that contains all positive values of the original array, in their original order, followed by all values that are zero or negative, in their original order.&lt;/p&gt;

&lt;p&gt;There’s a function called &lt;code&gt;partition&lt;/code&gt; built-in into Scala by &lt;a href=&quot;http://www.scala-lang.org/api/2.10.3/index.html#scala.collection.mutable.ArrayOps&quot;&gt;ArrayOps&lt;/a&gt; class, below is the implementation via &lt;code&gt;partition&lt;/code&gt;:
&lt;code&gt;scala
	val arr = Array(-1, 2, -3, -3.2, -9, 9, 8, 5, -10)
	val p = arr.partition {_ &amp;gt; 0}
	p._1 ++	p._2  // produce Array(2.0, 9.0, 8.0, 5.0, -1.0, -3.0, -3.2, -9.0, -10.0)
&lt;/code&gt;
Of course, we can also achieve without using the partition function, let’s do it:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;scala
	val ta = for (e &amp;lt;- a if e &amp;gt; 0) yield e
	val tb = for (e &amp;lt;- a if e &amp;lt;= 0) yield e
	ta ++ tb // produce: Array(2.0, 9.0, 8.0, 5.0, -1.0, -3.0, -3.2, -9.0, -10.0)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;5. How do you compute the average of an &lt;code&gt;Array[Double]&lt;/code&gt;?
&lt;code&gt;scala
	val arr = Array(-1, 2, -3, -3.2, -9, 9, 8, 5, -10)
	arr.sum / arr.size
&lt;/code&gt;
6. How do you rearrange the elements of an &lt;code&gt;Array[Int]&lt;/code&gt; so that they appear in reverse sorted order? How do you do the same with an &lt;code&gt;ArrayBuffer[Int]&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;With array, we can sort it in reverse order by below code:
&lt;code&gt;scala
	import scala.util.Sorting
	val arr = Array(-1, 2, -3, -3.2, -9, 9, 8, 5, -10)
	Sorting.quickSort(are)	// Sort the array in place
	arr.reverse
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;With ArrayBuffer:
&lt;code&gt;scala
	import collection.mutable.ArrayBuffer
	val a = ArrayBuffer(3, 2, 5, 8, 9, -1, -7)
	a.sortWith(_&amp;gt;_)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;7. Write a code snippet that produces all values from an array with duplicates removed. (Hint: Look at Scaladoc.)
&lt;code&gt;scala
	val arr = Array(1, 2, -1, 1, 2, 1)
	arr.distinct // produce Array(1, 2, -1)
&lt;/code&gt;
8. Rewrite the example at the end of Section 3.4, “Transforming Arrays,” on page 32. Collect indexes of the negative elements, reverse the sequence, drop the last index, and call &lt;code&gt;a.remove(i)&lt;/code&gt; for each index. Compare the efficiency of this approach with the two approaches in Section 3.4.&lt;/p&gt;

&lt;p&gt;We can get the same result with below code:
```scala
	import collection.mutable.ArrayBuffer&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val a = ArrayBuffer(1, 3, 9, -1, -6, 4, -2)
var indexes = for (i &amp;lt;- 0 until a.length if a(i) &amp;lt; 0) yield i
indexes = indexes.reverse
indexes.dropRight(1)
for (i &amp;lt;- 0 until indexes.length) {
	a.remove(indexes(i))
} ``` Now let see the time/space efficiency of above code. First, we use indexes to store the indexes of negative numbers, so it will take O(n) extra space. Then we traverse the original array for two times, reverse the indexes of negative numbers once, so the total time complexity will be 3 * O(n) ~ O(n)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;9. Make a collection of all time zones returned by &lt;code&gt;java.util.TimeZone.getAvailableIDs&lt;/code&gt; that are in America. Strip off the “America/” prefix and sort the result.
&lt;code&gt;scala
	val zones = java.util.TimeZone.getAvailableIDs()
	val zones_no_prefix = for (zone &amp;lt;- zones if zone.startsWith(&quot;America&quot;)) yield zone.stripPrefix(&quot;America/&quot;)
	util.Sorting.quickSort(zones_no_prefix)
&lt;/code&gt;
Another solution more in Scala way:
&lt;code&gt;scala
val zones = java.util.TimeZone.getAvailableIDs
val zones_no_prefix = zones.filter(_.startsWith(&quot;America/&quot;)).map(_.drop(&quot;America/&quot;.size))
util.Sorting.quickSort(zones_no_prefix)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;10. Import &lt;code&gt;java.awt.datatransfer._&lt;/code&gt; and make an object of type &lt;code&gt;SystemFlavorMap&lt;/code&gt; with the call &lt;code&gt;val flavors = SystemFlavorMap.getDefaultFlavorMap().asInstanceOf[SystemFlavorMap]&lt;/code&gt;, Then call the &lt;code&gt;getNativesForFlavor&lt;/code&gt; method with parameter &lt;code&gt;DataFlavor.imageFlavor&lt;/code&gt; and get the return value as a Scala buffer. (Why this obscure class? It’s hard to find uses of &lt;code&gt;java.util.List&lt;/code&gt; in the standard Java library.)
&lt;code&gt;scala
	val flavMap = SystemFlavorMap.getDefaultFlavorMap().asInstanceOf[SystemFlavorMap]
	val natives = flavMap.getNativesForFlavor(DataFlavor.imageFlavor)
&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://bitbucket.org/McDamon/scalaimpatient/src/4a11167459b2/ch03/answers.txt&quot;&gt;Scala for the Impatient solutions, by McDamon&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 07 Mar 2014 23:01:32 +0800</pubDate>
        <link>http://codethoughts.info/scala/2014/03/07/scala-for-the-impatient-chapter3/</link>
        <guid isPermaLink="true">http://codethoughts.info/scala/2014/03/07/scala-for-the-impatient-chapter3/</guid>
        
        
        <category>scala</category>
        
      </item>
    
      <item>
        <title>Differences among Blocks, Procs, and Lambdas in Ruby</title>
        <description>&lt;p&gt;Almost every Rubyist love Ruby’s Blocks, as well as Procs and Lambdas. These features allow you to pass code to a method then execute the piece of code at a later time. In this blog post, I’ll talk about the differences among them.&lt;/p&gt;

&lt;h3 id=&quot;blocks&quot;&gt;Blocks&lt;/h3&gt;
&lt;p&gt;A block is a piece of code passed to a method via curly braces &lt;code&gt;{...}&lt;/code&gt; or &lt;code&gt;do...end&lt;/code&gt;. By convention, &lt;code&gt;{...}&lt;/code&gt; is used within one line of code while &lt;code&gt;do...end&lt;/code&gt; for multi-line code. After passing into method, the block could be triggered later by &lt;code&gt;yield&lt;/code&gt; keyword to get a return value. The &lt;code&gt;yield&lt;/code&gt; keyword can accept parameters, which will be passed into the block it’s calling at that time. Let’s see a example:
&lt;code&gt;ruby
	def try
      yield if block_given?   
  	else  
      puts &quot;no block&quot;  
  end  
end  
&lt;/code&gt;
&lt;!--more--&gt;
Here we define a method call &lt;code&gt;try&lt;/code&gt;, you can detect if a block exist with the method &lt;code&gt;block_given?&lt;/code&gt;, which is defined in Kernel module. We can invoke the method &lt;code&gt;try&lt;/code&gt; like this:
&lt;code&gt;ruby
	try  								=&amp;gt; &quot;no block&quot;
	try {puts &quot;Hey, we see a block&quot;} 	=&amp;gt; &quot;Hey, we see a block&quot;
&lt;/code&gt;
It’s only a small demo, there’re block usage in Ruby code everywhere, most programmer from other programming languages are shocked by the power of Ruby blocks, which leads to concise code.&lt;/p&gt;

&lt;h3 id=&quot;procs&quot;&gt;Procs&lt;/h3&gt;
&lt;p&gt;A proc (Note that the proc is lowercase here) is also a piece of code, which are stored in a Proc instance. We can reuse this object any times we want. We can store a piece of code into a Proc instance, assign it to a variable, then pass it around. Let me show you another example:
&lt;code&gt;ruby
	def proc_demo(proc_obj)
	  proc_obj.call
	end
&lt;/code&gt;
Rather than the &lt;code&gt;yield&lt;/code&gt;, we use the &lt;code&gt;call&lt;/code&gt; method here to invoke the proc object passed in. Like the &lt;code&gt;yield&lt;/code&gt; keyword, the &lt;code&gt;call&lt;/code&gt; method can accept arguments either. We can invoke the above demo like this:
&lt;code&gt;ruby
	p = Proc.new { puts &quot;Hey, we see a proc&quot; }
	proc_demo(p)
&lt;/code&gt;
or
&lt;code&gt;ruby
	p0 = proc { puts &quot;Hey, we see a proc&quot; }
	proc_demo(p0)
&lt;/code&gt;
the code &lt;code&gt;proc {...}&lt;/code&gt; is equivalent to &lt;code&gt;Proc.new {...}&lt;/code&gt;, which produce a instance of Proc. You can check rdoc for further details about &lt;a href=&quot;http://www.ruby-doc.org/core-2.1.0/Proc.html&quot;&gt;Proc&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;lambdas&quot;&gt;Lambdas&lt;/h3&gt;
&lt;p&gt;The difference between a lambda and Proc instance is small. Basically there’re two differences between them.
* A lambda checks for the number of arguments it received, and will return &lt;code&gt;ArgumentError&lt;/code&gt; if the argument number don’t match. Let’s poke them around inside &lt;a href=&quot;http://pryrepl.org/&quot;&gt;pry&lt;/a&gt;, which is alternative of irb but can do much much more:&lt;/p&gt;

&lt;p&gt;First, let see the behaviour of lambda:
&lt;code&gt;ruby
[16] pry(main)&amp;gt; l = lambda {|name| puts &quot;Hello, #{name}&quot;}
=&amp;gt; #&amp;lt;Proc:0x007fc6a50f4560@(pry):9 (lambda)&amp;gt;
[17] pry(main)&amp;gt; l.call(&quot;George&quot;)
Hello, George
=&amp;gt; nil
[18] pry(main)&amp;gt; l.call
ArgumentError: wrong number of arguments (0 for 1)
from (pry):9:in `block in __pry__&#39;
[19] pry(main)&amp;gt; l.call(&quot;George&quot;, &quot;Puff&quot;)
ArgumentError: wrong number of arguments (2 for 1)
from (pry):9:in `block in __pry__&#39;
&lt;/code&gt;
Then with proc:
```ruby&lt;/p&gt;

&lt;p&gt;[21] pry(main)&amp;gt; p = proc {|name| puts “Hello #{name}”}
=&amp;gt; #&amp;lt;Proc:0x007fc6a4a6c5f8@(pry):14&amp;gt;
[22] pry(main)&amp;gt; p.call
Hello
=&amp;gt; nil
[23] pry(main)&amp;gt; p.call(“George”)
Hello George
=&amp;gt; nil
[24] pry(main)&amp;gt; p.call(“George”, “Puff”)
Hello George
=&amp;gt; nil
```
The difference of processing the incoming arguments is pretty clear with above example.&lt;/p&gt;

&lt;p&gt;&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;Another difference is that lambda provide diminutive returns, which means when a Proc encounters a return statement during it’s execution, it halts the enclosing method then return the provided value. Lambdas, on the other hand, return the value to the method, then return to the enclosing method, continue the program execution. This means procs behave more like a piece of code, while lambdas more like a method, you can take advantage of them of your own.&lt;/p&gt;

&lt;p&gt;If you still not clear about the differences among them, I recommand you to read the excellent book &lt;a href=&quot;http://www.amazon.com/Metaprogramming-Ruby-Program-Like-Pros/dp/1934356476&quot;&gt;Metaprogramming Ruby&lt;/a&gt;, check the book comments on Amazon.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://code.tutsplus.com/tutorials/ruby-on-rails-study-guide-blocks-procs-and-lambdas--net-29811&quot;&gt;Ruby on Rails Study Guide: Blocks, Procs, and Lambdas&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 24 Feb 2014 22:17:52 +0800</pubDate>
        <link>http://codethoughts.info/ruby/2014/02/24/blocks-procs-lambdas/</link>
        <guid isPermaLink="true">http://codethoughts.info/ruby/2014/02/24/blocks-procs-lambdas/</guid>
        
        
        <category>ruby</category>
        
      </item>
    
      <item>
        <title>Solutions to Scala for the Impatient - Chapter1 and Chapter2</title>
        <description>&lt;p&gt;Recently I’m reading the book &lt;a href=&quot;http://www.amazon.com/Scala-Impatient-Cay-S-Horstmann/dp/0321774094&quot;&gt;Scala for the Impatient&lt;/a&gt;, the book is pretty brilliant, you can see that from the comments. Since I’m a newbie to Scala, I’m try to complete the exercises after every chapter, I post the solutions in a serious of blog posts as book notes.&lt;/p&gt;

&lt;p&gt;Since both chapter 1 and chapter 2 are very simple, I’ll post the solutions together here with this blog post.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;solutions-to-exercises-of-chapter-1&quot;&gt;Solutions to exercises of Chapter 1&lt;/h3&gt;
&lt;p&gt;8. One way to create random file or directory names is to produce a random BigInt and convert it to base 36, yielding a string such as “qsnvbevtomcj38o06kul”. Poke around Scaladoc to find a way of doing this in Scala.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BigInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;util&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;36&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;According to &lt;a href=&quot;http://www.scala-lang.org/api/2.10.2/index.html#scala.math.BigInt$&quot;&gt;BigInt’s document&lt;/a&gt;, there’s a method called apply, which will construct a randomly generated BigInt, uniformly distributed over the range 0 to (2 ^ numBits - 1), its method signature is:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numbits&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rnd&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BigInt&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;9. How do you get the first character of a string in Scala? The last character?&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;abcd&amp;quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// get the first&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dropRight&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;There’re several way to achieve this goal, what I have shown is one of them.&lt;/p&gt;

&lt;p&gt;10. What do the take, drop, takeRight, and dropRight string functions do? What advantage or disadvantage do they have over using substring?
To get an idea what they can do, we need to check Scala document.&lt;/p&gt;

&lt;p&gt;The difference between then and java.lang.String is that, before Java 7, String#substring method will operate on the original string, it will generate new String instance at all, so it takes constant time to complete the substring operation. But this behaviour changed after Java 7 due to security reasons, for more details, please go to &lt;a href=&quot;http://www.javaadvent.com/2012/12/changes-to-stringsubstring-in-java-7.html&quot;&gt;Changes to String.substring in Java 7&lt;/a&gt;. After this change, substring will always produce new String instances, which will take linear time to complete the operation.&lt;/p&gt;

&lt;p&gt;As far as I know, in Scala, the &lt;code&gt;take\*&lt;/code&gt; and &lt;code&gt;drop\*&lt;/code&gt; method will always generate new String instances(please correct me if I’m wrong), I think this is the difference.&lt;/p&gt;

&lt;h3 id=&quot;solutions-to-exercises-of-chapter-2&quot;&gt;Solutions to exercises of Chapter 2&lt;/h3&gt;
&lt;p&gt;1. The signum of a number is 1 if the number is positive, –1 if it is negative, and 0 if it is zero. Write a function that computes this value.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;signum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Notice that I didn’t use return statement in above code, it a best practice to avoid the return statement in Scala.&lt;/p&gt;

&lt;p&gt;2. What is the value of an empty block expression {}? What is its type?
It’s of type Unit, you can verify that with &lt;code&gt; {}.getClass &lt;/code&gt; inside Scala interactive shell.&lt;/p&gt;

&lt;p&gt;3. Come up with one situation where the assignment x = y = 1 is valid in Scala. (Hint: Pick a suitable type for x.)&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Unit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Unit&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4.Write a Scala equivalent for the Java loop &lt;code&gt;for (int i = 10; i &amp;gt;= 0; i--) System.out.println(i); &lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5. Write a procedure countdown(n: Int) that prints the numbers from n to 0.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;countdown&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;step&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;6. Write a for loop for computing the product of the Unicode codes of all letters in a string. For example, the product of the characters in “Hello” is 9415087488L.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prod&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;Hello&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prod&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;7. Solve the preceding exercise without writing a loop. (Hint: Look at the StringOps Scaladoc.)&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Hello&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foldLeft&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Note that here I use 1L instead of 1, because java.lang.Integer.MAX_VALUE is 2147483647, which is too small to hold the produce of products of “Hello”, so I need to specify Long as the products type.&lt;/p&gt;

&lt;p&gt;8. Write a function product(s : String) that computes the product, as described in the preceding exercises.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;product&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foldLeft&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;9. Make the function of the preceding exercise a recursive function.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;product_r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toInt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;product_r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Note that we still specify the return value as Long for the same reason above.&lt;/p&gt;

</description>
        <pubDate>Mon, 24 Feb 2014 20:09:58 +0800</pubDate>
        <link>http://codethoughts.info/scala/2014/02/24/scala-for-the-impatient-solutions-ch1-and-ch2/</link>
        <guid isPermaLink="true">http://codethoughts.info/scala/2014/02/24/scala-for-the-impatient-solutions-ch1-and-ch2/</guid>
        
        
        <category>scala</category>
        
      </item>
    
      <item>
        <title>Threading with Monitor in Ruby</title>
        <description>&lt;p&gt;Write multi-threaded program is pretty straightforward in Ruby, there’s a Thread class that help to achieve parallelism code. If you didn’t know thread or don’t know how to write multi-threaded code in Ruby, I encourage you stop reading this blog post, move to this brilliant tutorial &lt;a href=&quot;http://www.tutorialspoint.com/ruby/ruby_multithreading.htm&quot;&gt;Ruby Multithreading&lt;/a&gt; to learn the basics of the Thread in Ruby.&lt;/p&gt;

&lt;p&gt;Well, this blog post will show you how to make your life easier as a Ruby developer when you faced with multi-threading – the MonitorMixin library, it’s one of my favourite libraries. It make the task of writing complex synchronisation logic easy which is hard to write using a simple exclusive locking mechanism. MonitorMixin lets you write a nested lock, so you can use it as a more convenient version of plain old Mutex.&lt;/p&gt;

&lt;p&gt;Let’s see an example with deadlock, then we resolve it with MonitorMixin library.
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;Here’s the defected code:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;thread&amp;#39;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Todo&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initialize&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt;     &lt;span class=&quot;vi&quot;&gt;@items&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt;     &lt;span class=&quot;vi&quot;&gt;@serial&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;# Exclusive mutex instance&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt;     &lt;span class=&quot;vi&quot;&gt;@mutex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Mutex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;# No need to synchronize here because we only read value here&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;# But keep in mind that in Ruby you can redefine method,&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;# so this method may not behave as it should be.&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;15&lt;/span&gt;     &lt;span class=&quot;vi&quot;&gt;@items&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;16&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;17&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;18&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;19&lt;/span&gt;     &lt;span class=&quot;vi&quot;&gt;@mutex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;synchronize&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;20&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;# Deadlock happens here.&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;21&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serial&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;22&lt;/span&gt;       &lt;span class=&quot;vi&quot;&gt;@items&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;vi&quot;&gt;@key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;23&lt;/span&gt;       &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;24&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;25&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;26&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;27&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;28&lt;/span&gt;     &lt;span class=&quot;vi&quot;&gt;@mutex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;synchronize&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;29&lt;/span&gt;       &lt;span class=&quot;vi&quot;&gt;@items&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;30&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;31&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;32&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;33&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_todos&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;34&lt;/span&gt;     &lt;span class=&quot;vi&quot;&gt;@mutex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;synchronize&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;35&lt;/span&gt;       &lt;span class=&quot;vi&quot;&gt;@items&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;collect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;vi&quot;&gt;@items&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;36&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;37&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;38&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;39&lt;/span&gt;   &lt;span class=&quot;kp&quot;&gt;private&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;40&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;41&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;# Generate next serial number&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;42&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;serial&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;43&lt;/span&gt;     &lt;span class=&quot;vi&quot;&gt;@mutex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;synchronize&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;44&lt;/span&gt;       &lt;span class=&quot;vi&quot;&gt;@serial&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;45&lt;/span&gt;       &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;vi&quot;&gt;@serial&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;46&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;47&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;48&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Let’s try it in interactive Ruby, note that I use &lt;a href=&quot;http://pryrepl.org/&quot;&gt;Pry&lt;/a&gt; as replacement of plain old irb, you should give it a try too, it’s pretty powerful.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;require_relative&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;deadlock_example&amp;#39;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;todo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Todo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#&amp;lt;Todo:0x007f866977fb90 @items={}, @mutex=#&amp;lt;Mutex:0x007f866977fb40&amp;gt;, @serial=0&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;todo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;Item 1&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;ThreadError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deadlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recursive&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;locking&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/Users/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gsun&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prog&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ruby&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;george&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deadlock_example&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;39&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:in&lt;/span&gt; &lt;span class=&quot;sb&quot;&gt;`synchronize&amp;#39;&lt;/span&gt;
&lt;span class=&quot;sb&quot;&gt;[33] pry(main)&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Sure enough, we have a deadlock on our hands. These types of bugs can be difficult to track down in real life programming.&lt;/p&gt;

&lt;p&gt;Now let’s see how to use MonitorMixin to enable nested lock, above example was refactored like this:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;monitor&amp;#39;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Todo&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt;   &lt;span class=&quot;kp&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;MonitorMixin&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initialize&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;# Remember to call super in constructor to initialize MonitorMixin&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;# Also no need the @mutex instance at all&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt;     &lt;span class=&quot;vi&quot;&gt;@items&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt;     &lt;span class=&quot;vi&quot;&gt;@serial&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;15&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;# No need to synchronize here because we only read value here&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;16&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;# But keep in mind that in Ruby you can redefine method,&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;17&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;# so this method may not behavior as it should be.&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;18&lt;/span&gt;     &lt;span class=&quot;vi&quot;&gt;@items&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;19&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;20&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;21&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;22&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;synchronize&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;23&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;# Deadlock happens here.&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;24&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serial&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;25&lt;/span&gt;       &lt;span class=&quot;vi&quot;&gt;@items&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;vi&quot;&gt;@key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;26&lt;/span&gt;       &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;27&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;28&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;29&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;30&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;31&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;synchronize&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;32&lt;/span&gt;       &lt;span class=&quot;vi&quot;&gt;@items&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;33&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;34&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;35&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;36&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_todos&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;37&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;synchronize&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;38&lt;/span&gt;       &lt;span class=&quot;vi&quot;&gt;@items&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;collect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;vi&quot;&gt;@items&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;39&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;40&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;41&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;42&lt;/span&gt;   &lt;span class=&quot;kp&quot;&gt;private&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;43&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;44&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;# Generate next serial number&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;45&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;serial&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;46&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;synchronize&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;47&lt;/span&gt;       &lt;span class=&quot;vi&quot;&gt;@serial&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;48&lt;/span&gt;       &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;vi&quot;&gt;@serial&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;49&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;50&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;51&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now let’s try it in Pry:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;require_relative&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;example&amp;#39;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;todo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Todo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#&amp;lt;Todo:0x007ff1f2a30a98&lt;/span&gt;
 &lt;span class=&quot;vi&quot;&gt;@items&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;
 &lt;span class=&quot;vi&quot;&gt;@mon_count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
 &lt;span class=&quot;vi&quot;&gt;@mon_mutex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;#&amp;lt;Mutex:0x007ff1f2a30a48&amp;gt;,&lt;/span&gt;
 &lt;span class=&quot;vi&quot;&gt;@mon_owner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
 &lt;span class=&quot;vi&quot;&gt;@serial&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;todo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;Item 1&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The deadlock is gone since the synchronize method can handle nested locks, you don’t have to worry about having a deadlock, unlike the Mutex version. If you know Java, you can see the synchronize method is similar to the synchronized keyword in Java.&lt;/p&gt;

&lt;p&gt;The moral is that we should consider MonitorMixin library for every case that need synchronize, even the simplest one.&lt;/p&gt;

</description>
        <pubDate>Sat, 25 Jan 2014 00:45:07 +0800</pubDate>
        <link>http://codethoughts.info/ruby/2014/01/25/threading-with-monitor-in-ruby/</link>
        <guid isPermaLink="true">http://codethoughts.info/ruby/2014/01/25/threading-with-monitor-in-ruby/</guid>
        
        
        <category>ruby</category>
        
      </item>
    
  </channel>
</rss>
